/*++

NASM Assembly Language Plugin
Copyright (c) 2017-2018 Aidan Khoury. All rights reserved.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

--*/

{
    parserClass="com.nasmlanguage.parser.NASMParser"
    parserUtilClass="com.nasmlanguage.parser.NASMParserUtil"

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="NASM"
    psiImplClassSuffix="Impl"
    psiPackage="com.nasmlanguage.psi"
    psiImplPackage="com.nasmlanguage.psi.impl"

    elementTypeHolderClass="com.nasmlanguage.psi.NASMTypes"
    elementTypeClass="com.nasmlanguage.psi.NASMElementType"
    tokenTypeClass="com.nasmlanguage.psi.NASMTokenType"

    psiImplUtilClass="com.nasmlanguage.psi.impl.NASMPsiImplUtil"

    tokens = [
        CRLF                = 'regexp:\r|\n|\r\n'
        WHITE_SPACE         = 'regexp:[ \t\x0B\f]+'

        COMMENT             = 'regexp:(;.*?(\r|\n|\r\n)?)'
        EQU                 = 'regexp:([eE][qQ][uU])'

        SEGMENT_ADDR_L      = 'regexp:((0[xX][0-9a-fA-F]+|0[hH][0-9a-fA-F]+|\$[0-9]+[0-9a-fA-F]*|[0-9]+[0-9a-fA-F]*[hH])|[0]*):'

        INCLUDE_TAG         = 'regexp:(({WHITE_SPACE})?[#%]({WHITE_SPACE})?)([iI][nN][cC][lL][uU][dD][eE])'
        DEFINE_TAG          = 'regexp:(({WHITE_SPACE})?[#%]({WHITE_SPACE})?)(([xX]|[iI])?[dD][eE][fF][iI][nN][eE])'
        ASSIGN_TAG          = 'regexp:(({WHITE_SPACE})?[#%]({WHITE_SPACE})?)([iI]?[aA][sS][sS][iI][gG][nN])'

        MACRO_TAG           = 'regexp:(({WHITE_SPACE})?[#%]({WHITE_SPACE})?)([iI]?[mM][aA][cC][rR][oO])'
        MACRO_END_TAG       = 'regexp:(({WHITE_SPACE})?[#%]({WHITE_SPACE})?)([iI]?[eE][nN][dD][mM][aA][cC][rR][oO])'
        MACRO_PARAM_REF     = 'regexp:((%|%%)([1-9][0-9]*))'
        MACRO_VAR_REF       = 'regexp:((%%)([a-zA-Z0-9$._?][a-zA-Z0-9$._?#@\126]*))'
        MACRO_PARAM_LBL_DEF = 'regexp:((((%|%%)([a-zA-Z0-9$._?][a-zA-Z0-9$._]*))|(([a-zA-Z0-9$._?][a-zA-Z0-9$._]*)((%)[0-9]+)[a-zA-Z0-9$._]*)):)'
        IF_TAG              = 'regexp:(({WHITE_SPACE})?[#%]({WHITE_SPACE})?)([iI][fF][nN]?([dD][eE][fF])?)'
        IFMACRO_TAG         = 'regexp:(({WHITE_SPACE})?[#%]({WHITE_SPACE})?)([iI][fF][mM][aA][cC][rR][oO])'
        IFCTX_TAG           = 'regexp:(({WHITE_SPACE})?[#%]({WHITE_SPACE})?)([iI][fF][cC][tT][xX])'
        ELIF_TAG            = 'regexp:(({WHITE_SPACE})?[#%]({WHITE_SPACE})?)([eE][lL][iI][fF][nN]?([dD][eE][fF])?)'
        ELSE_TAG            = 'regexp:(({WHITE_SPACE})?[#%]({WHITE_SPACE})?)([eE][lL][sS][eE])'
        ENDIF_TAG           = 'regexp:(({WHITE_SPACE})?[#%]({WHITE_SPACE})?)([eE][nN][dD][iI][fF])'

        STRLEN_TAG          = 'regexp:((({WHITE_SPACE})?[#%]({WHITE_SPACE})?)([sS][tT][rR][lL][eE][nN]))'
        ERROR_TAG           = 'regexp:((({WHITE_SPACE})?[#%]({WHITE_SPACE})?)([eE][rR][rR][oO][rR])).*'

        SECTION             = 'regexp:(([sS][eE][cC][tT][iI][oO][nN])({WHITE_SPACE})((\.)([a-zA-Z_]+[a-zA-Z0-9_]*)))'
        SEGMENT             = 'regexp:(([sS][eE][gG][mM][eE][nN][tT])({WHITE_SPACE})([a-zA-Z_]+[a-zA-Z0-9_]*))'

        //CODE_SECTION_NAME   = 'regexp:(\.[tT][eE][xX][tT])'
        //DATA_SECTION_NAME   = 'regexp:(\.[dD][aA][tT][aA])'
        //RDATA_SECTION_NAME  = 'regexp:(\.[rR][dD][aA][tT][aA])'
        //BSS_SECTION_NAME    = 'regexp:(\.[bB][sS][sS])'

        MAP_OPTIONS         = 'regexp:(all|brief|sections|segments|symbols)'
        MAP_FILE            = 'regexp:(([a-zA-Z0-9_.]+)(\.)[mM][aA][pP])'

        STRUC_TAG           = 'regexp:([sS][tT][rR][uU][cC])'
        ENDSTRUC_TAG        = 'regexp:([eE][nN][dD][sS][tT][rR][uU][cC])'
        ISTRUC_TAG          = 'regexp:([iI][sS][tT][rR][uU][cC])'
        IEND_TAG            = 'regexp:([iI][eE][nN][dD])'
        AT_TAG              = 'regexp:([aA][tT])'
        STRUCT_FIELD        = 'regexp:(([a-zA-Z_]+[a-zA-Z0-9_]*)(\.)([a-zA-Z_]+[a-zA-Z0-9_]*))'
        SEGMENT_ADDR_L      = 'regexp:((0[xX][0-9a-fA-F]+|0[hH][0-9a-fA-F]+|\$[0-9]+[0-9a-fA-F]*|[0-9]+[0-9a-fA-F]*[hH])|[0]*):'

        DIRECTIVE_OP        = 'regexp:([bB][iI][tT][sS]|[uU][sS][eE]16|[uU][sS][eE]32|[cC][oO][dD][eE]16|[cC][oO][dD][eE]32|[aA][bB][sS][oO][lL][uU][tT][eE]|[eE][xX][tT][eE][rR][nN]|[gG][lL][oO][bB][aA][lL]|[oO][rR][gG]|[aA][lL][iI][gG][nN]|[sS][tT][rR][uU][cC]|[eE][nN][dD][sS][tT][rR][uU][cC]|[cC][oO][mM][mM][oO][nN]|[cC][pP][uU]|[gG][rR][oO][uU][pP]|[uU][pP][pP][eE][rR][cC][aA][sS][eE]|[iI][mM][pP][oO][rR][tT]|[eE][xX][pP][oO][rR][tT]|[lL][iI][bB][rR][aA][rR][yY]|[mM][oO][dD][uU][lL][eE])'
        END_DIRECTIVE_OP    = 'regexp:([eE][nN][dD])'
        PREPROCESSOR_OP     = 'regexp:(({WHITE_SPACE})?[#%]({WHITE_SPACE})?)([xX]?[iI]?[dD][eE][fF][iI][nN][eE]|[uU][nN][dD][eE][fF]|[aA][sS][sS][iI][gG][nN]|[iI]?[dD][eE][fF][sS][tT][rR]|[iI]?[dD][eE][fF][tT][oO][kK]|[sS][tT][rR][cC][aA][tT]|[sS][tT][rR][lL][eE][nN]|[sS][uU][bB][sS][tT][rR]|[iI]?[mM][aA][cC][rR][oO]|[eE][nN][dD][mM][aA][cC][rR][oO]|[rR][oO][tT][aA][tT][eE]|[rR][eE][pP]|[eE][nN][dD][rR][eE][pP])'
        DATA_OP             = 'regexp:([rR][eE][sS][bBwWdDqQtToOyYzZ]|[dD][bBwWdDqQtToOyYzZ]|[tT][iI][mM][eE][sS])'

        // General purpose instructions
        INS_DATA_TRANS_MOV  = 'regexp:(mov([sz]x)?|cmov(n?[abceglopsz]|n?[abgl]e|p[eo]))|(xchg|bswap|xadd|cmpxchg(8b)?)'                                // Data Transfer MOV
        INS_DATA_TRANS_XCHG = 'regexp:(xchg|bswap|xadd|cmpxchg(8b)?)'                                                                                   // Data Transfer XCHG
        INS_DATA_TRANS_OTHER= 'regexp:((push|pop)(ad?)?|cwde?|cdq|cbw)'                                                                                 // Data Transfer Other
        INS_DECIMAL_ARITH   = 'regexp:(daa|das|aaa|aas|aam|aad)'                                                                                        // Decimal Arithmetic
        INS_BINARY_ARITH    = 'regexp:(adcx?|adox|add|sub|sbb|i?mul|i?div|inc|dec|neg|cmp)'                                                             // Binary Arithmetic
        INS_BINARY_LOGICAL  = 'regexp:(and|x?or|not)'                                                                                                   // Binary Logical
        INS_BINARY_ROTATE   = 'regexp:(s[ah][rl]|sh[rl]d|r[co][rl])'                                                                                    // Binary Rotation
        INS_BINARY_SET      = 'regexp:(set(n?[abceglopsz]|n?[abgl]e|p[eo]))'                                                                            // Binary Set
        INS_BINARY_OTHER    = 'regexp:(bt[crs]?|bs[fr]|test|crc32|popcnt)'                                                                              // Binary Other
        INS_CONTROL_TRANS   = 'regexp:(jmp|jn?[abceglopsz]|jn?[abgl]e|jp[eo]|j[er]?cxz)|(loop(n?[ez])?|call|ret[fn]?|iret[dq]?|into?|bound|enter|leave)'// Control Transfer
        INS_STRING_DATA     = 'regexp:((mov|cmp|sca|lod|sto)(s[bdw]?)|rep(n?[ez])?)'                                                                    // String Data
        INS_INPUT_OUTPUT    = 'regexp:((in|out)(s[bdw]?)?)'                                                                                             // I/O
        INS_FLAG_CONTROL    = 'regexp:((st|cl)[cdi]|cmc|[ls]ahf|(push|pop)f[dq]?)'                                                                      // Flag Control
        INS_SEG_REGS        = 'regexp:(l[defgs]s)'                                                                                                      // Segment Registers
        INS_MISC_OTHER      = 'regexp:(lea|nop|ud2|xlatb?|cpuid|movbe)'                                                                                 // Misc/Other
        INS_RNG_RAND        = 'regexp:(rdrand|rdseed)'                                                                                                  // Random Number Generation (RNG)
        INS_BIT_MANIPULATION= 'regexp:(andn|bextr|bls(i|r|msk)|bzhi|pdep|pext|[lt]zcnt|(mul|ror|sar|shl|shr)x)'                                         // Bit Manipulation (BMI)

        // System instructions
        INS_SYSTEM          = 'regexp:((cl|st)ac|[ls]([gli]dt|tr|msw)|clts|arpl|lar|lsl|ver[rw]|inv(d|lpga?|pcid)|wbinvd)|(lock|hlt|rsm|(rd|wr)(msr|pkru|[fg]sbase)|rd(pmc|tscp?)|sys(enter|exit))|(x((save(c|opt|s)?|rstors?)(64)?|[gs]etbv))'

        // Virtualization instructions
        INS_INTEL_VMX       = 'regexp:(vm(ptr(ld|st)|clear|read|write|launch|resume|xo(ff|n)|call|func)|inv(ept|vpid))'
        INS_AMD_SVM         = 'regexp:(vm(run|load|save|mcall)|stgi|clgi|skinit)'

        // 64 bit instructions
        INS_64_BIT          = 'regexp:(cdqe|cqo|(cmp|lod|mov|sto)sq|cmpxchg16b|mov(ntq|sxd)|scasq|swapgs|sys(call|ret))'                                // 64 bit Instructions

        // FPU instructions
        INS_FPU_DATA_TRANS  = 'regexp:(fcmov(n?([beu]|be)))|(f(i?(ld|stp?)|b(ld|stp)|xch))'                                                             // FPU Data Transfer
        INS_FPU_BASIC_ARITH = 'regexp:(f((add|div|mul|sub)p?|i(add|div|mul|sub)|(div|sub)rp?|i(div|sub)r))|(f(prem1?|abs|chs|rndint|scale|sqrt|xtract))'// FPU Basic Arithmetic
        INS_FPU_COMPARISON  = 'regexp:(f(u?com[ip]?p?|icomp?|tst|xam))'                                                                                 // FPU Comparison
        INS_FPU_TRANSCEND   = 'regexp:(f(sin|cos|sincos|pa?tan|2xm1|yl2x(p1)?))'                                                                        // FPU Transcendental
        INS_FPU_LOAD        = 'regexp:(fld(1|z|pi|l2[et]|l[ng]2))'                                                                                      // FPU Load
        INS_FPU_CONTROL     = 'regexp:(f((inc|dec)stp|free|n?(init|clex|st[cs]w|stenv|save)|ld(cw|env)|rstor|nop)|f?wait)'                              // FPU Control Management
        INS_FPU_STATE       = 'regexp:(fx(save|rstor)(64)?)'                                                                                            // FPU State Management

        // MMX instructions
        INS_MMX_DATA_TRANS  = 'regexp:(mov[dq])'
        INS_MMX_CONVERSION  = 'regexp:(pack(ssdw|[su]swb)|punpck[hl](bw|dq|wd))'
        INS_MMX_ARITH       = 'regexp:(p(((add|sub)(d|(u?s)?[bw]))|maddwd|mul[lh]w))'
        INS_MMX_COMPARISON  = 'regexp:(pcmp((eq|gt)[bdw]))'
        INS_MMX_LOGICAL     = 'regexp:(pandn?|px?or)'
        INS_MMX_ROTATE      = 'regexp:(ps([rl]l[dwq]|raw|rad))'
        INS_MMX_STATE       = 'regexp:(emms)'

        // SSE instructions
        INS_SSE_DATA_TRANS  = 'regexp:(mov(([ahlu]|hl|lh|msk)ps|ss))'
        INS_SSE_ARITH       = 'regexp:((add|div|max|min|mul|rcp|r?sqrt|sub)[ps]s)'
        INS_SSE_COMPARISON  = 'regexp:(cmp[ps]s|u?comiss)'
        INS_SSE_LOGICAL     = 'regexp:((andn?|x?or)ps)'
        INS_SSE_OTHER       = 'regexp:((shuf|unpck[hl])ps)'
        INS_SSE_CONVERSION  = 'regexp:(cvt(pi2ps|si2ss|ps2pi|tps2pi|ss2si|tss2si))'
        INS_SSE_STATE       = 'regexp:((ld|st)mxcsr)'
        INS_SSE_SIMD_INT    = 'regexp:(p(avg[bw]|extrw|insrw|(max|min)(sw|ub)|sadbw|shufw|mulhuw|movmskb))'
        INS_SSE_CACHE_CTRL  = 'regexp:(maskmovq|movntps|sfence)'
        INS_SSE_PREFETCH    = 'regexp:(prefetch(nta|t[0-2]|w(t1)?))'

        // SSE2 instructions
        INS_SSE2_DATA_TRANS = 'regexp:(mov([auhl]|msk)pd)'
        INS_SSE2_ARITH      = 'regexp:((add|div|max|min|mul|sub|sqrt)[ps]d)'
        INS_SSE2_LOGICAL    = 'regexp:((andn?|x?or)pd)'
        INS_SSE2_COMPARISON = 'regexp:((cmpp|u?comis)d)'
        INS_SSE2_OTHER      = 'regexp:((shuf|unpck[hl])pd)'
        INS_SSE2_CONVERSION = 'regexp:(cvt(dq2pd|pi2pd|ps2pd|pd2ps|si2sd|sd2ss|ss2sd|t?(pd2dq|pd2pi|sd2si)))|(cvt(dq2ps|ps2dq|tps2dq))'
        INS_SSE2_SIMD_INT   = 'regexp:(mov(dq[au]|q2dq|dq2q))|(p((add|sub|(s[lr]l|mulu|unpck[hl]q)d)q|shuf(d|[hl]w)))'
        INS_SSE2_CACHE_CTRL = 'regexp:(clflush|[lm]fence|pause|maskmovdqu|movnt(dq|i|pd))'

        // SSE3 instructions
        INS_SSE3_GENERAL    = 'regexp:(fisttp|lddqu|(addsub|h(add|sub))p[sd]|mov(sh|sl|d)dup|monitor|mwait)'
        INS_SSE3_ARITH      = 'regexp:(ph(add|sub)(s?w|d))'
        INS_SSE3_OTHER      = 'regexp:(p((abs|sign)[bdw]|maddubsw|mulhrsw|shufb|alignr))'

        // SSE4 instructions
        INS_SSE4_ARITH      = 'regexp:(pmul(ld|dq)|dpp[ds])'
        INS_SSE4_DATA_TRANS = 'regexp:(movntdqa)'
        INS_SSE4_BLEND      = 'regexp:(blendv?p[ds]|pblend(vb|w))'
        INS_SSE4_PACKED_INT = 'regexp:(p(min|max)(u[dw]|s[bd]))'
        INS_SSE4_PACKED_FP  = 'regexp:(round[ps][sd])'
        INS_SSE4_INS_EXT    = 'regexp:((extract|insert)ps|p((ins|ext)(r[bdq])))'
        INS_SSE4_CONVERSION = 'regexp:(pmov([sz]x(b[dqw]|dq|wd|wq)))'
        INS_SSE4_OTHER      = 'regexp:(mpsadbw|phminposuw|ptest|pcmpeqq|packusdw)|(pcmp([ei]str[im]|gtq))'

        // AVX instructons
        INS_AVX_GENERAL     = 'regexp:(v((test|permil|maskmov)p[ds]|zero(all|upper)|(perm2|insert|extract|broadcast)f128|broadcasts[ds]))'
        INS_AVX_AES         = 'regexp:(vaes((dec|enc)(last)?|imc|keygenassist)|vpclmulqdq)'
        INS_AVX_COMPARISON  = 'regexp:(v((cmp[ps]|u?comis)[ds]|pcmp([ei]str[im]|(eq|gt)[bdqw])))'
        INS_AVX_CONVERSION  = 'regexp:((v(cvt(dq2pd|dq2ps|pd2ps|ps2pd|sd2ss|si2sd|si2ss|ss2sd|t?(pd2dq|ps2dq|sd2si|ss2si))))|(vcvt(ph2ps|ps2ph)))'
        INS_AVX_LOGICAL     = 'regexp:((v((andn?|x?or)p[ds]))|(vp(andn?|x?or)))'
        INS_AVX_MOV         = 'regexp:((v(mov(([ahl]|msk|nt|u)p[ds]|(hl|lh)ps|s([ds]|[hl]dup)|q)))|(vpmov(mskb|[sz]x(b[dqw]|w[dq]|dq)))|(vmov(d(dup|qa|qu)?)))'
        INS_AVX_ARITH       = 'regexp:((v((add|div|mul|sub|max|min|round|sqrt)[ps][ds]|(addsub|dp)p[ds]|(rcp|rsqrt)[ps]s))|(vh((add|sub)p[ds])|vph((add|sub)([dw]|sw)|minposuw)))'
        INS_AVX_PACKED      = 'regexp:((v(pack[su]s(dw|wb)|punpck[hl](bw|dq|wd|qdq)|unpck[hl]p[ds]))|(vp(shuf([bd]|[hl]w))|vshufp[ds])|(vp((abs|sign|(max|min)[su])[bdw]|(add|sub)([bdqw]|u?s[bw])|avg[bw]|extr[bdqw]|madd(wd|ubsw)|mul(hu?w|hrsw|l[dw]|u?dq)|sadbw)))'
        INS_AVX_BLEND       = 'regexp:((vpblend(vb|w))|(vblendv?p[ds]))'
        INS_AVX_CACHE       = 'regexp:(v(maskmovdqu|movntdqa?))'
        INS_AVX_FMA3        = 'regexp:(vfn?m((add|sub)(132|213|231)[ps][ds])|vfm((addsub|subadd)(132|213|231)p[ds]))'
        INS_AVX_OTHER       = 'regexp:((vp(test|alignr))|(v((extract|insert)ps|lddqu|(ld|st)mxcsr|mpsadbw)))'

        // AVX2 instructions
        INS_AVX2_SIMD       = 'regexp:(v((extract|insert|perm2)i128|pmaskmov[dq]|perm([dsq]|p[sd])))'
        INS_AVX2_BROADCAST  = 'regexp:(vpbroadcast[qwbd]|vbroadcast(sd|ss)|vbroadcasti128)'
        INS_AVX2_BLEND      = 'regexp:(vp(blendd|s[lr]lv[dq]|sravd))'
        INS_AVX2_GATHER     = 'regexp:(vp?gather[dq][dq]|vgather([dq]|dq)p[ds])'

        // AVX512 instructions
        INS_AVX512_BLEND    = 'regexp:(vblendm(pd|ps)|vpblendm[bdqw])'
        INS_AVX512_BROADCAST= 'regexp:(vbroadcast[fi](32x[248]|64x[24])|vpbroadcastm(b2q|w2d))'
        INS_AVX512_MOV      = 'regexp:(vmovdq(a(32|64)|u(8|16|32|64))|v(extract|insert)[fi](32x[48]|64x[24])|vshuf[fi](32x4|64x2))'
        INS_AVX512_COMPRESS = 'regexp:(v(compress|expand)p[ds]|vp(compress|expand|conflict)[dq])'
        INS_AVX512_CONV     = 'regexp:(vcvt(t?p[sd]2(udq|u?qq)|(udq|u?qq)2p[ds]|t?s[ds]2usi|usi2s[ds]))'
        INS_AVX512_MATH     = 'regexp:((v(fixupimm|fpclass|get(exp|mant)|range|(rcp|rsqrt)(14|28)|reduce|rndscale|scalef)([ps][ds]))|(v(exp2p[ds]|(scatter|(gather|scatter)pf[01])[dq]p[ds])))'
        INS_AVX512_LOGICAL  = 'regexp:(vp(andn?|x?or)[dq])'
        INS_AVX512_COMPARE  = 'regexp:(vpcmpu?[dqw])'
        INS_AVX512_PACKED   = 'regexp:((vp(absq|(lzcnt|ternlog)[dq]|madd52[lh]uq|(max|min)[su]q|mullq))|(vpmov(m2[bdqw]|[bdqw]2m|(u?s)?([qd][bw]|qd|wb)))|(vp(ro[rl]v?[dq]|scatter[dq][dq]))|(vptestn?m[bdqw]))'
        INS_AVX512_PERM     = 'regexp:(vperm([bdw]|[it]2([bdwq]|p[ds])))'
        INS_AVX512_OTHER    = 'regexp:(valign[dq]|vdbpsadbw|vpmultishiftqb|vpsrav[dqw])'


        // Instruction operation prefixes
        OP_PREFIX           = 'regexp:((rep(n?[ez])|rep)|lock)'

        // Instructions
        GENERAL_OP          = 'regexp:{INS_DATA_TRANS_MOV}|{INS_DATA_TRANS_XCHG}|{INS_DATA_TRANS_OTHER}|{INS_DECIMAL_ARITH}|{INS_BINARY_ARITH}|{INS_BINARY_LOGICAL}|{INS_BINARY_ROTATE}|{INS_BINARY_SET}|{INS_BINARY_OTHER}|{INS_CONTROL_TRANS}|{INS_STRING_DATA}|{INS_INPUT_OUTPUT}|{INS_FLAG_CONTROL}|{INS_SEG_REGS}|{INS_MISC_OTHER}|{INS_RNG_RAND}|{INS_BIT_MANIPULATION}'
        SYSTEM_OP           = 'regexp:{INS_SYSTEM}'
        VIRTUALIZATION_OP   = 'regexp:{INS_INTEL_VMX}|{INS_AMD_SVM}'
        X64_OP              = 'regexp:{INS_64_BIT}'
        FPU_OP              = 'regexp:{INS_FPU_DATA_TRANS}|{INS_FPU_BASIC_ARITH}|{INS_FPU_COMPARISON}|{INS_FPU_TRANSCEND}|{INS_FPU_LOAD}|{INS_FPU_CONTROL}|{INS_FPU_STATE}'
        MMX_OP              = 'regexp:{INS_MMX_DATA_TRANS}|{INS_MMX_CONVERSION}|{INS_MMX_ARITH}|{INS_MMX_COMPARISON}|{INS_MMX_LOGICAL}|{INS_MMX_ROTATE}|{INS_MMX_STATE}'
        SSE_OP              = 'regexp:{INS_SSE_DATA_TRANS}|{INS_SSE_ARITH}|{INS_SSE_COMPARISON}|{INS_SSE_LOGICAL}|{INS_SSE_OTHER}|{INS_SSE_CONVERSION}|{INS_SSE_STATE}|{INS_SSE_SIMD_INT}|{INS_SSE_CACHE_CTRL}|{INS_SSE_PREFETCH}'
        SSE2_OP             = 'regexp:{INS_SSE2_DATA_TRANS}|{INS_SSE2_ARITH}|{INS_SSE2_LOGICAL}|{INS_SSE2_COMPARISON}|{INS_SSE2_OTHER}|{INS_SSE2_CONVERSION}|{INS_SSE2_SIMD_INT}|{INS_SSE2_CACHE_CTRL}'
        SSE3_OP             = 'regexp:{INS_SSE3_GENERAL}|{INS_SSE3_ARITH}|{INS_SSE3_OTHER}'
        SSE4_OP             = 'regexp:{INS_SSE4_ARITH}|{INS_SSE4_DATA_TRANS}|{INS_SSE4_BLEND}|{INS_SSE4_PACKED_INT}|{INS_SSE4_PACKED_FP}|{INS_SSE4_INS_EXT}|{INS_SSE4_CONVERSION}|{INS_SSE4_OTHER}'
        AVX_OP              = 'regexp:{INS_AVX_GENERAL}|{INS_AVX_AES}|{INS_AVX_COMPARISON}|{INS_AVX_CONVERSION}|{INS_AVX_LOGICAL}|{INS_AVX_MOV}|{INS_AVX_ARITH}|{INS_AVX_PACKED}|{INS_AVX_BLEND}|{INS_AVX_CACHE}|{INS_AVX_FMA3}|{INS_AVX_OTHER}'
        AVX2_OP             = 'regexp:{INS_AVX2_SIMD}|{INS_AVX2_BROADCAST}|{INS_AVX2_BLEND}|{INS_AVX2_GATHER}'
        AVX512_OP           = 'regexp:{INS_AVX512_BLEND}|{INS_AVX512_BROADCAST}|{INS_AVX512_MOV}|{INS_AVX512_COMPRESS}|{INS_AVX512_CONV}|{INS_AVX512_MATH}|{INS_AVX512_LOGICAL}|{INS_AVX512_COMPARE}|{INS_AVX512_PACKED}|{INS_AVX512_PERM}|{INS_AVX512_OTHER}'


        // All kinds of registers
        REGISTER            = 'regexp:(%)?(([c-gs]s):)?(([abcd][hl])|([er]?[abcd]x)|([er]?[sb]p)|([er]?[sd]i|dil|sil|bpl|spl)|([er]?ip)|(r(8|9|1[0-5])[bdlw]?)|([er]?flags)|(cr[0-8])|(d[rb][0-367]|dr([89]|1[0-5]))|(tr[3-7])|(([gil]dt)r?|tr)|(bnd([0-3]|cfg[su]|status))|(efer|tpr|syscfg)|((mm|st|fpr)[0-7])|([xy]mm([0-9]|1[0-5])|mxcsr)|(zmm([12]?[0-9]|30|31)))'
        SEGMENT_REGISTER    = 'regexp:([c-gs]s)'
        SIZE_TYPE           = 'regexp:[sS][hH][oO][rR][tT]|[lL][oO][nN][gG]|[nN][eE][aA][rR]|[fF][aA][rR]|(((([dDqQoOtTyYzZ]|[xX][mM][mM])?[wW][oO][rR][dD])|[bB][yY][tT][eE])(([ \t\x0B\f]+)[pP][tT][rR])?)'

        // Make last!
        ID                  = 'regexp:([a-zA-Z_]+[a-zA-Z0-9_%]*)' // Some identifier
        LBL_DEF             = 'regexp:([a-zA-Z$._?#@\126]+[a-zA-Z0-9_]*):' // Label definition
        LBL                 = 'regexp:([a-zA-Z$._?#@\126]+[a-zA-Z0-9_]*)' // Label can have chars like '%', '.', '?', '@', etc

        // Literals
        BINARY              = 'regexp:(0[bB][0-1]+|0[yY][0-1]+|[0-1][0-1]*[bB]|[0-1][0-1]*[yY])'
        HEXADECIMAL         = 'regexp:(0[xX][0-9a-fA-F]+|0[hH][0-9a-fA-F]+|\$[0-9]+[0-9a-fA-F]*|[0-9]+[0-9a-fA-F]*[hH])'
        ZEROES              = 'regexp:[0]+'
        DECIMAL             = 'regexp:((([1-9][0-9]*\.?[0-9]*)|(\.[0-9]+))([Ee][+-]?[0-9]+)?|0[dD][0-9]+|[0-9]+)'
        //SEGMENT_ADDR        = 'regexp:(((0[xX][0-9a-fA-F]+|0[hH][0-9a-fA-F]+|\$[0-9]+[0-9a-fA-F]*|[0-9]+[0-9a-fA-F]*[hH])|[0]+):((0[xX][0-9a-fA-F]+|0[hH][0-9a-fA-F]+|\$[0-9]+[0-9a-fA-F]*|[0-9]+[0-9a-fA-F]*[hH])|[a-zA-Z_][a-zA-Z0-9_]*|[0]+))'
        CHARACTER           = "regexp:('([^'\\]|\\.)')"
        STRING              = "regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")"

        COLON               = ':'
        SEMICOLON           = ';'
        SQUARE_L            = '['
        SQUARE_R            = ']'
        ROUND_L             = '('
        ROUND_R             = ')'
        SEPARATOR           = ','
        DOT                 = '.'
        QUESTION            = '?'

        EQUAL               = '='
        EQUALEQUAL          = '=='
        PLUS                = '+'
        MINUS               = '-'
        TIMES               = '*'
        DIVIDE              = '/'
        BITSHIFT_L          = '<<'
        BITSHIFT_R          = '>>'
        BITWISE_AND         = '&'
        BITWISE_OR          = '|'
        BITWISE_XOR         = '^'
        BITWISE_NOT         = '~'

        DOLLARSIGN          = '$'
        DOLLARSIGN2         = '$$'
        PERCENT             = '%'
        PERCENT2            = '%%'
    ]
}

NASMFile ::= Element*
private Element ::= COMMENT
                | CRLF
                | COMMENT CRLF
                | Section
                | Segment
                | Preprocessor
                | Directive
                | EndDirective
                | Constant
                | Label
                | Structure
                | Data
                | Instruction
                | ID CRLF
                ;

private Section ::= (((SQUARE_L SECTION SQUARE_R) | SECTION) CRLF*)
private Segment ::= (((SQUARE_L SEGMENT SQUARE_R) | SEGMENT) CRLF*)

Preprocessor ::= Include | Define | Assign | Macro | Strlen | Error | Conditional | (PREPROCESSOR_OP Identifier Expr)
Include ::= (INCLUDE_TAG STRING) {methods=[getIncludeString]}
Define ::= (DEFINE_TAG Identifier ROUND_L (Identifier (SEPARATOR Identifier)*)? ROUND_R Expr CRLF*)
        | (DEFINE_TAG Identifier (Expr|(PERCENT SQUARE_L Expr SQUARE_R)) CRLF*) {methods=[getDefineIdentifier getDefineIdentifierString]}
Assign ::= (ASSIGN_TAG Identifier Expr)
Macro ::= MACRO_TAG (Identifier MacroParams MacroDefaultParam? CRLF* (MacroLabel|Data|Instruction|Preprocessor|ID CRLF*)*) MACRO_END_TAG { pin=1 methods=[getMacroIdentifier]}
MacroLabel ::= (MACRO_PARAM_LBL_DEF (Instruction|Data)? CRLF*)
private MacroParams ::= ((NumericLiteral MINUS NumericLiteral TIMES?)|(NumericLiteral MINUS TIMES)|(NumericLiteral PLUS?))
private MacroDefaultParam ::= (Instruction|STRING|REGISTER|NumericLiteral|MacroCall)
Strlen ::= STRLEN_TAG Identifier (STRING|Identifier) CRLF*
Error ::= ERROR_TAG CRLF*
Conditional ::= (IF_TAG Condition CRLF* (Preprocessor|Constant|Directive|Label|Structure|Data|Instruction)* ((ELIF_TAG Condition|ELSE_TAG) CRLF* (Preprocessor|Constant|Directive|Label|Structure|Data|Instruction)*)* ENDIF_TAG CRLF*)
            | (IFMACRO_TAG Identifier MacroParams MacroDefaultParam? CRLF* (Preprocessor|Directive|Data|Instruction)* ENDIF_TAG)
private Condition ::= ((Expr EQUALEQUAL Expr)|Expr)

Label ::= (((LBL_DEF (Instruction|Data|Structure)?) | (LabelDefMacro (Instruction|Data|Structure)?)) CRLF*) {methods=[getLabelIdentifierString]} // (((LBL_DEF (Instruction|Data|Structure)?)|LabelInstruction|LabelData) CRLF*)
LabelDefMacro ::= (MacroCall COLON CRLF*)
Constant ::= (Identifier EQU ((MINUS|PLUS)? NumericExpr) CRLF*) {methods=[getConstantIdentifierString]}

//LabelData ::= (LBL_DATA DataValue CRLF*) {methods=[getLabelIdentifierString]}
Data ::= (Identifier? DATA_OP DataValue)
private DataValue ::= ((MINUS|PLUS)? (NumericExpr|STRING|LabelIdentifier) (SEPARATOR ((MINUS|PLUS)? (NumericExpr|STRING|LabelIdentifier)))* COMMENT?)

Structure ::= ((Struc|IStruc) CRLF*)
Struc ::= (STRUC_TAG Identifier CRLF* (((LBL_DEF|LabelIdentifier) DATA_OP ((MINUS|PLUS)? (NumericExpr|Identifier)) CRLF*)|((LabelIdentifier|LBL_DEF) CRLF*))* ENDSTRUC_TAG)
IStruc ::= (ISTRUC_TAG Identifier CRLF* (AT_TAG (StructureField|LabelIdentifier|Identifier) SEPARATOR DATA_OP DataValue CRLF*)* IEND_TAG)

//LabelInstruction ::= (((LBL_INS ((Expr SEPARATOR)* Expr)?)|Directive|MacroCall) CRLF*) {methods=[getLabelIdentifierString]}
Instruction ::= (((OP_PREFIX? Mnemonic (((((BITWISE_NOT|MINUS|PLUS)? Expr) SEPARATOR)* ((BITWISE_NOT|MINUS|PLUS)? Expr))|(SIZE_TYPE (BITWISE_NOT|MINUS|PLUS)? ROUND_L Expr ROUND_R))?)|Directive|MacroCall) CRLF*)
private Mnemonic ::= (GENERAL_OP|SYSTEM_OP|VIRTUALIZATION_OP|X64_OP|FPU_OP|MMX_OP|SSE_OP|SSE2_OP|SSE3_OP|SSE4_OP|AVX_OP|AVX2_OP|AVX512_OP)

MapOption ::= SQUARE_L 'map' ('all'|'brief'|'sections'|'segments'|'symbols')? MAP_FILE SQUARE_R

Directive ::= (DirectiveDecl|DirectiveDeclBrackets|MapOption) CRLF*
private DirectiveDecl ::= DIRECTIVE_OP DirectiveArg*
private DirectiveDeclBrackets ::= SQUARE_L DirectiveDecl SQUARE_R
DirectiveArg ::= ((MINUS|PLUS)? (MacroCall|NumericLiteral|Address|SegmentAddress|Identifier))

EndDirective ::= (END_DIRECTIVE_OP) { extends=Expr }


// Root expression rules
Expr ::= ParenthesisExpr
        | MulExpr
        | DivExpr
        | PlusExpr
        | MinusExpr
        | ModulusExpr
        | BitShiftLExpr
        | BitShiftRExpr
        | BitwiseANDExpr
        | BitwiseORExpr
        | BitwiseXORExpr
        | BitwiseNOTExpr
        | NumericLiteral
        | SegmentAddress
        | Str
        | StructureField
        | MacroCall
        | MacroParamReference
        | MacroVarReference
        | Address
        | Reg
        | Seg
        | Identifier
        | LabelIdentifier
        | EndDirective
        ;
NumericExpr ::= ParenthesisNumericExpr
        | MulExpr
        | DivExpr
        | PlusExpr
        | MinusExpr
        | ModulusExpr
        | BitShiftLExpr
        | BitShiftRExpr
        | BitwiseANDExpr
        | BitwiseORExpr
        | BitwiseXORExpr
        | BitwiseNOTExpr
        | NumericLiteral
        | SegmentAddress
        | Str
        | StructureField
        | MacroCall
        | MacroParamReference
        | MacroVarReference
        | Address
        | Identifier
        | LabelIdentifier
        ;

MulExpr ::= Expr TIMES Expr { extends=Expr }
DivExpr ::= Expr DIVIDE Expr { extends=Expr }
PlusExpr ::= Expr PLUS Expr { extends=Expr }
MinusExpr ::= Expr MINUS Expr { extends=Expr }
ModulusExpr ::= Expr PERCENT Expr { extends=Expr }
BitShiftLExpr ::= Expr BITSHIFT_L Expr { extends=Expr }
BitShiftRExpr ::= Expr BITSHIFT_R Expr { extends=Expr }
BitwiseANDExpr ::= Expr BITWISE_AND Expr { extends=Expr }
BitwiseORExpr ::= Expr BITWISE_OR Expr { extends=Expr }
BitwiseXORExpr ::= Expr BITWISE_XOR Expr { extends=Expr }
BitwiseNOTExpr ::= BITWISE_NOT NumericExpr { extends=Expr }
ParenthesisExpr ::= ROUND_L Expr ROUND_R { pin(".*")=1 extends=Expr }
ParenthesisNumericExpr ::= ROUND_L NumericExpr ROUND_R { pin(".*")=1 extends=NumericExpr }

NumericLiteral ::= ((SIZE_TYPE (BITWISE_NOT|MINUS|PLUS)?)? (BINARY|ZEROES|HEXADECIMAL|DECIMAL|CHARACTER)) { extends=Expr }
Identifier ::= (ID) { extends=Expr mixin="com.nasmlanguage.psi.impl.NASMNamedElementImpl" implements="com.nasmlanguage.psi.NASMNamedElement" methods=[getName setName getNameIdentifier getReferences getPresentation] }
LabelIdentifier ::= (SIZE_TYPE? (LBL|ID)) { extends=Expr }
Reg ::= REGISTER { extends=Expr }
Seg ::= SEGMENT_REGISTER { extends=Expr }
Str ::= STRING { extends=Expr }
StructureField ::= STRUCT_FIELD { extends=Expr }
SegmentAddress ::= (SIZE_TYPE? ((SEGMENT_ADDR_L (HEXADECIMAL|ZEROES|MacroCall|ID|LBL))|
                                (LBL_DEF (SIZE_TYPE? (HEXADECIMAL|ZEROES|MacroCall|ID|LBL)))|
                                (LabelDefMacro (SIZE_TYPE? (HEXADECIMAL|ZEROES|MacroCall|ID|LBL))))) { extends=Expr }
Address ::= ((SIZE_TYPE? AddressInternal)|DOLLARSIGN|DOLLARSIGN2) { extends=Expr }
private AddressInternal ::= (SQUARE_L MINUS? Expr SQUARE_R) { pin(".*")=1 }
MacroCall ::= ((SIZE_TYPE? (Identifier MacroParenthesis))|(SIZE_TYPE? (Identifier NumericExpr))) { extends=Expr }
private MacroParenthesis ::= (ROUND_L (NumericExpr (SEPARATOR NumericExpr)*)? ROUND_R) { pin(".*")=1 }
MacroParamReference ::= (SIZE_TYPE? MACRO_PARAM_REF) { extends=Expr }
MacroVarReference ::= (SIZE_TYPE? MACRO_VAR_REF) { extends=Expr }


//private PrefixedExpr ::= (MINUS|PLUS)? Expr
//private PrefixedNumericExpr ::= (MINUS|PLUS)? NumericExpr